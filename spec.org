* Overview
** Sociobot is a Telegram bot.
** It allows to select a lesson and pay to unlock it.
** It lists links to unlocked lessons.
** Admin can view stats, add new lessons or modify existing via the bot.
** Admin is notified about the purchases.
** There is only one admin.
** All user interactions with the bot are in Russian.

* User interaction
** General rules
*** Bot should remove a button if the user should not click it.
*** Bot should mark a message with a reaction if it is out-of-date.
*** If the user clicks an invalid button, bot should send an explaination.
*** If the user sends a message to the bot, bot should reply with an explaination and a button "Forward to support".
**** The "Forward" button makes the bot forward the message to the admin.
** User opens the bot using a link.
** User click the "Start" button.
** Bot sends a greeting, instructions and a prompt for the user's real name.
** After receiving a reply from the user the bot sends a message with the received name and buttons "Continue" and "Change".
*** The "Change" button sends a prompt again.
** After the user set the real name the bot displays a menu with buttons.
*** Unlock lessons
**** Bot sends a message with an instruction and a list of lessons.
**** Each lesson in the list has a number, bold title, description with a link to a video teaser and a price.
**** Bot sends a message with a prompt for the lesson number and a button "Cancel".
**** If the user sends an invalid input, bot replies to it with an instruction and a button "Cancel".
**** Bot sends a message with a lesson description, a video instruction on how to pay and buttons "Pay online" and "Cancel".
**** After clicking the "Pay" button a payment service opens in the browser.
**** Bot sends a message "Waiting for payment" and a button "Cancel the payment".
***** If the user successfully completes the payment.
****** Bot sends a message with a receipt and a link to the lesson.
****** Bot sends the admin a notification with the user name, receipt and the lesson title.
***** If the payment fails.
****** Bot sends a message indicating the failure reason and buttons "Try again" and "Cancel".
******* The "Try again" button acts as if the user clicked the "Unlock" link for the lesson.
******* The "Cancel" button makes the bot send an acknowledgement message.
***** User clicked the "Cancel the payment" button.
****** Bot sends an acknowledgement message.
***** User does nothing for more than 1 hour.
****** Bot sends a message asking if the user still interested with buttons "Yes" and "No".
****** The "Yes" button makes the bot send a message with an instruction and a "Pay online" button with an updated link.
****** The "No" button makes the bot send an acknowledgement message.
*** My lessons (unlocked)
**** Bot sends a message wtih an instruction and a list of lessons.
**** Each lesson in the list has a bold title, description and a link to the content.
*** Help
**** Bot sends an instruction with a video and a link to a support chat.

* Admin interaction
** Admin is identified via a user name statically stored in the bot configuration.
** Admin has all the menu buttons that a regular user has.
** Admin is able to pay for a lesson for debugging purposes.
** Besides the "Unlock" link, admin should be given a "Free unlock" link that acts as if a payment succeeded.
** Button "Add a lesosn"
*** Bot sends a message with instructions, prompt for the admin to send a title and a button "Cancel".
*** After receiving a message from the admin, bot sends a message with the title, prompt for the description and buttons "Edit title" and "Cancel".
*** The "Cancel" button sends a message asking for confirmation. If not confirmed, the previous prompt message is repeated.
*** The "Edit title" button acts the same as the "Add a lesson" button but without instructions.
*** After receiving the description, bot sends a message with the description, prompt for the link and buttons "Edit description", "Edit title" and "Cancel".
*** The "Edit description" button acts as if the admin just sent the title reply.
*** The "Edit title" button sends a prompt for title and a "Cancel" button. After receiving the title, the bot sends acts as if a description was just sent, but modifies the title.
*** After receiving the link, the bot sends a message with the link it just received, a prompt for the price and buttons "Edit link", "Edit title", "Edit description" and "Cancel".
*** After receiving the price, the bot sends a message with a lesson description as seen by users and buttons "Add", "Edit price", "Edit description", "Edit title", "Cancel".
*** The "Add" button sends an acknowledgement message.
** Button "Edit a lesson"
*** Bot sends a message with a numbered lessons list as seen by the user and a prompt to pick a lesson number to edit.
*** If the admin sends an invalid input, the bot replies to it with an instruction and a button "Cancel".
*** After receiving a lesson number, the bot sends a lesson description as seen by the user and buttons "Edit title", "Edit description", "Edit link", "Edit price", "Cancel".
*** The "Edit" buttons send a prompt and after receiving the input the bot sends an updated lesson description with the same "Edit" buttons but "Cancel" is replaced with "Done".
*** The "Done" button sends an acknowledgement.
*** If a price was lowered, the acknowledgement message has a button "Notify about the price" that sends a notification to all users who do not have the lesson unlocked. 
** Button "Delete a lesson"
*** Bot sends a message with a numbered lessons list as seen by the user and a prompt to pick a lesson number to delete as in the "Edit" command.
*** After receiving a lesson number, the bot sends a lesson description as seen by the user and buttons "Delete", "Pick another" and "Cancel".
*** The "Delete" button asks for confirmation.
*** The "Pick another" acts the same way as the "Delete a lesson button" but without the sending the list.
** Button "Statistics"
*** Bot sends a list of lesson titles. For each title there is a list of user names who have the lesson unlocked.
** Button "Block forwards"
*** The bot sends a numbered list of user names who have ever used the "Forward to support" button together with a status - "Not blocked" or "Blocked".
*** If the admin enters the number of an unblocked user the bot sends the username with buttons "Block", "Pick another" and "Cancel".
*** If the admin enters the number of a blocked user, the bot sends the username with buttons "Unblock", "Pick another" and "Cancel".

* Modules
** Events
*** All modules use "sob_ev" for events
**** "sob_ev_type": get type from enum "sob_ev_types"
**** "sob_ev_data": get data as uint64_t. May be invalid for some types
** "tg": Telegram
*** Credentials
**** "cred_tg_token"
*** Data
**** "tg_handle": Module handle
**** "tg_chat": Chat handle
***** "tg_chat_id": telegram id as unit64
***** "tg_chat_name": get first_name and last_name as an utf-8 string (joined with space). May be out of date. Updated with received messages
***** "tg_chat_username": get username as an ascii string. May be out of date. Updated with received messages
**** "tg_msg": Message handle
***** "tg_msg_from_ev": get msg handle from "sob_ev"
***** "tg_msg_is_delivered": true after "ev_tg_sent"
***** "tg_msg_is_failed": true after "ev_tg_send_fail"
***** "tg_msg_is_deleted": true after "ev_tg_msg_deleted"
***** "tg_msg_id": telegram id as uint32. Valid only if "tg_msg_is_delivered" and not "tg_msg_is_deleted"
***** "tg_msg_chat": get "tg_chat"
***** "tg_msg_text": get message content as an utf-8 string
***** "tg_msg_print": description to use in logs as an ascii string (max length - "tg_msg_print_len")
**** "tg_btn": Button handle (from message inline-markup)
***** "tg_btn_is_delivered": true after "ev_tg_sent" for "tg_btn_msg"
***** "tg_btn_is_deleted": true after "ev_tg_msg_btn_deleted" or "ev_tg_msg_deleted". false when not "tg_btn_is_delivered"
***** "tg_btn_text": get button text as a utf-8 string
***** "tg_btn_msg": get Message handle that this button belongs to
**** "tg_reaction": single utf-8 emoji char of 4 bytes
***** "tg_reaction_desc": get an ascii string like "<thumbs-up-react>"
**** "tg_msg_to_send": Message object to use with "tg_send_msg"
***** "tg_s_msg_set_chat": set target "tg_chat"
***** "tg_s_msg_set_text": set text as an utf-8 string with markdownV2 formatting 
***** "tg_s_msg_add_btn": add an inline keyboard button with given text as an utf-8 string
***** "tg_s_msg_add_kb_btn": add a reply keyboard button with given text as an utf-8 string. Buttons will replace existing
***** "tg_s_msg_remove_kb": remove reply keyboard. Previous and following calls to "tg_s_msg_add_kb_btn" will have no effect
*** Events
**** "ev_tg_msg": user sent a message
**** "ev_tg_btn": user clicked a button
**** "ev_tg_init": initialization completed after "tg_init"
**** "ev_tg_init_fail": initialization failed after "tg_init"
**** "ev_tg_stopped": module is ready to stop after "tg_stop_prep". "tg_stop" can be called safely
**** "ev_tg_sent": message request was delivered to telegram after "tg_send_msg"
**** "ev_tg_send_fail": impossible to send a message after "tg_send_msg". Module tries hard so likely it is network failure or api error
- "tg_send_fail_desc": ascii string with event description (max length - "tg_send_fail_desc_len")
**** "ev_tg_forwarded": after "tg_fwd_msg"
**** "ev_tg_fwd_fail": after "tg_fwd_msg"
**** "ev_tg_deleted": after "tg_del_msg"
**** "ev_tg_del_fail": after "tg_del_msg"
**** "ev_tg_reacted": after "tg_react_msg"
**** "ev_tg_react_fail": after "tg_react_msg"
**** "ev_tg_msg_updated": after "tg_msg_upd_text"
**** "ev_tg_msg_upd_fail": after "tg_msg_upd_text"
**** "ev_tg_btn_deleted": after "tg_msg_del_button"
**** "ev_tg_btn_del_fail': after "tg_msg_del_button"
*** Methods
**** Each method here is bound to a module handle. There may be multiple handles
**** "tg_init": start initialization of a "tg_handle"
- Second call with same handle will do nothing unless "tg_stop" was called
- Module will actually initialize after event "ev_tg_init"
- Methods if called immediately after will fail. Exceptions: "tg_pollfds", "tg_update", "tg_events" - they will work normally
**** "tg_stop_prep": signal the module to begin shutdown. "tg_pollfds" must be serviced, possibly multiple times
**** "tg_stop": signal the module that the program is closing
- Use only after event "ev_tg_stopped"
- "tg_pollfds" and "tg_events" will be empty after this call
- All other methods will fail
- Call "tg_init" to use the module again
**** "tg_events": get list of module specific events
- Multiple calls will return same events before "tg_update"
- Old events are removed after "tg_update"
**** "tg_pollfds": get list of "pollfs" to watch for
**** "tg_update": notify the "tg" module about result of "poll"
**** "tg_send_msg": send message "tg_msg_to_send"
- Message is actually sent only after "ev_tg_sent"
- Fails immediately if the target chat does not exist
- "ev_tg_send_fail" if a message cannot be sent and further retries will certainly not help
**** "tg_fwd_msg": forward message
- Fails immediately if the source message or the target chat does not exist
- Events: "ev_tg_forwarded", "ev_tg_fwd_fail"
- "ev_tg_fwd_fail": no permissions for the target chat, network failure
**** "tg_del_msg": delete message
- Fails immediately if a message is older than 48 hours or was already deleted
- Events: "ev_tg_deleted", "ev_tg_del_fail"
**** "tg_react_msg": set a reaction to message
- Fails immediately if the message does not exist
- Events: "ev_tg_reacted", "ev_tg_react_fail"
- Changes reaction if was already set
**** "tg_msg_upd_text": set new message text
- Fails immediately if the message does not exist
- Events: "ev_tg_msg_updated", "ev_tg_msg_upd_fail"
**** "tg_msg_del_button": remove a button from message reply-markup
- Fails immediately if the button does not exist
- Events: "ev_tg_btn_deleted", "ev_tg_btn_del_fail"
*** Data storage
**** All messages are stored persistently (sent or not)
**** All chats are stored persistently (data may be outdated)
**** Messages and chats are stored in file "$PWD/tg.dat"
***** Key-value pairs separated with ":"
***** Keys are ascii, values may be in utf-8
***** Spaces and tabs around ":" are ignored
***** Chat keys are in format "chat.<chat handle id>.<key>" where "<chat handle id>" corresponds to "tg_chat"
***** Message keys are in format "msg.<msg handle id>.<key>" where "<msg handle id>" corresponds to "tg_msg"
***** Button keys are in format "msg.<msg handle id>.btn.<btn handle id>.<key>" where "<btn handle id>" corresponds to "tg_btn"
***** Value for the ".text" is multiline
***** ".text" starts with "<" and ends with ">". "<" and ">" are escaped as "\<" and "\>"
***** First newline after "<" is ignored". First newline before ">" is ignored
***** Other values are enclosed in double quotes. Everything inside quotes is treated literally
*** Example
#+begin_src C
sob_ev evs[228];
tg_handle tg;
tg_init(tg);

while (1) {
    struct pollfd pollfds[42];
    nfds_t nfds = tg_pollfds(tg, pollfds, 42);
    poll(pollfds, nfds, 10000);
    tg_update(tg, pollfds, nfds);
    uint16_t n_evs = tg_events(tg, evs, 228);
    for (int i = 0; i < n_evs; i++) {
        switch (sob_ev_type(evs[i])) {
        case ev_tg_init:
            printf("init!\n");
            break;
        case ev_tg_init_fail:
            goto fail;
        case ev_tg_msg:
            tg_msg msg = tg_msg_from_ev(&evs[i]);
            tg_msg_to_send s_msg;
            tg_s_msg_set_chat(s_msg, tg_msg_chat(msg));
            tg_s_msg_set_text(s_msg, tg_msg_text(msg));
            tg_send_msg_res res = tg_send_msg(tg, &s_msg);
            if (tg_send_msg_res_ok(res)) {
                tg_msg r_msg = tg_send_msg_res_ok_msg(res);
                char msg_debug[tg_msg_print_len];
                tg_msg_print(msg, msg_debug);
                printf("enqueued message: '%s'\n", msg_debug);
            } else if (tg_send_msg_res_fail(res)) {
                fprintf(stderr,
                    "tg_send_msg failed: '%s'\n",
                    tg_send_msg_res_fail_desc(res));
            } else { }
            break;
        case ev_tg_sent:
            printf("echo delivered\n");
            break;
        case ev_tg_send_fail:
            char desc[tg_send_fail_desc_len];
            tg_send_fail_desc(evs[i], desc);
            fprintf(stderr, "Failed to send echo: '%s'\n", desc);
            goto fail;
        default:
            continue;
        }
    }
}

fail:
tg_stop_prep(tg);
while (1) {
    struct pollfd pollfds[42];
    nfds_t nfds = tg_pollfds(tg, pollfds, 42);
    poll(pollfds, nfds, 10000);
    tg_update(tg, pollfds, nfds);
    uint16_t n_evs = tg_events(tg, evs, 228);
    for (int i = 0; i < n_evs; i++) {
        switch (sob_ev_type(evs[i])) {
        case ev_tg_stopped:
            goto stopped;
        }
    }
}
stopped:
tg_stop(tg);
exit(1);
#+end_src
** "yk": YouKassa
*** Credentials
**** "cred_yk_shop_id", "cred_yk_token"
*** Data
**** "yk_handle": Module handle
**** "yk_payment": Payment handle
***** "yk_pay_from_ev": get "yk_payment" from "sob_ev"
***** "yk_pay_is_pending": true after "ev_yk_pay_started"
***** "yk_pay_is_failed": true after "ev_yk_pay_fail"
***** "yk_pay_id": ascii string, 36 chars, id in youkassa, valid after "ev_yk_pay_started"
***** "yk_pay_url": ascii string, url to redirect the user to pay, valid if "yk_pay_is_pending" (max length - "yk_pay_url_len")
***** "yk_pay_fail_desc": ascii string describing failure reason, valid if "yk_pay_is_failed" (max length - "yk_pay_fail_desc_len")
***** "yk_pay_print": ascii string to use in logs (max length - "yk_pay_print_len")
**** "yk_payment_req": Payment data to use with "yk_pay"
***** "yk_r_pay_set_rub": set amount with uint16 for number of rubbbles and uint8 for kopek
***** "yk_r_pay_set_desc": set description as an utf-8 string to be shown to the user during checkout, up to 128 chars
***** "yk_r_pay_set_email": set user email for receipt as an ascii string (mandatory but can be replaced with "yk_r_pay_set_phone")
***** "yk_r_pay_set_phone": set user phone for receipt as an ascii string (mandatory but can be replaced with "yk_r_pay_set_email")
***** "yk_r_pay_set_name": set user fullname for receipt as an utf-8 string (mandatory)
***** "yk_r_pay_add_item": add an item for receipt with utf-8 description (up to 128 chars) and amount as two ints for rubs and kopek, up to 6 items
*** Events
**** "ev_yk_init": initialization complete after "yk_init"
**** "ev_yk_init_fail": initialization failed after "yk_init"
**** "ev_yk_pay_wait_capture": a payment was authorized (state "waiting_for_capture") after "ev_yk_pay_started"
**** "ev_yk_pay_fail": payment failed and it is invalid now after "ev_yk_pay_started"
**** "ev_yk_pay_expired": payment was not completed on time and it is invalid now after "ev_yk_pay_started"
**** "ev_yk_stopped": module is ready to stop after "yk_stop_prep"
**** "ev_yk_pay_started": payment was sent to youkassa and is "pending" after "yk_pay"
**** "ev_yk_pay_start_fail": impossible to start a payment after "yk_pay". likely a network failure
**** "ev_yk_pay_captured": payment was captured and money is transfered after "yk_capture"
**** "ev_yk_capture_fail": after "yk_capture"
**** "ev_yk_canceled": after "yk_cancel"
**** "ev_yk_cancel_fail": after "yk_cancel"
*** Methods
**** Each method here is bound to a module handle. There may be multiple handles
**** "yk_init": start initialization of the module handle
- Events: "ev_yk_init", "ev_yk_init_fail"
- Second call with same handle will do nothing unless "yk_stop" was called
- Module will actually initialize after event "ev_yk_init"
- Methods if called immediately after will fail. Exceptions: "yk_pollfds", "yk_update", "yk_events" - they will work normally
**** "yk_stop_prep": begin module shutdown. "yk_pollfds" must be serviced, possibly multiple times
**** "yk_stop": signal the module that the program is closing
- Use only after event "ev_yk_stopped"
- "yk_pollfds" and "yk_events" will be empty after this call
- All other methods will fail
- Call "yk_init" to use the module again
**** "yk_events": get list of module specific events
- Multiple calls will return same events before "yk_update"
- Old events are removed after "yk_update"
**** "yk_pollfds": get list of "pollfs" to watch for
**** "yk_update": notify the module about result of "poll"
**** "yk_pay": start a payment and return "yk_payment" handle using data from "yk_payment_req"
- Payment is only actually started after "ev_yk_pay_started"
- Events: "ev_yk_pay_started", "ev_yk_pay_start_fail"
**** "yk_capture": capture a payment to actually transfer the money
- Only valid after "ev_yk_pay_wait_capture"
- Fails immediately after "yk_cancel" (even before "ev_yk_canceled" or after "ev_yk_cancel_fail")
- Fails immediately after "ev_yk_pay_fail", "ev_yk_pay_expired"
- Events: "ev_yk_pay_captured", "ev_yk_capture_fail"
**** "yk_cancel": cancel a payment
- Fails immediately after "yk_capture"
- Fails immediately after "ev_yk_pay_fail", "ev_yk_pay_expired"
- Events: "ev_yk_canceled", "ev_yk_cancel_fail"
*** Data storage
**** All payments are stored persistently (even not started and canceled)
**** File: "$PWD/youkassa.dat"
**** Key-value pairs separated with ":"
**** Keys are ascii, values may be in utf-8
**** Spaces and tabs around ":" are ignored
**** Values are enclosed in double quotes. Everything inside quotes is treated literally
**** Keys are in format "<handle id>.<key>" where "<handle id>" corresponds to "yk_payment"
*** Example
#+begin_src C
sob_ev evs[228];
yk_handle yk;
yk_init(yk);

while (1) {
    struct pollfd pollfds[42];
    nfds_t nfds = yk_pollfds(yk, pollfds, 42);
    poll(pollfds, nfds, 10000);
    yk_update(yk, pollfds, nfds);
    uint16_t n_evs = yk_events(yk, evs, 228);
    for (int i = 0; i < n_evs; i++) {
        switch (sob_ev_type(evs[i])) {
        case ev_yk_init:
            printf("init!\n");

            yk_payment_req pay;
            yk_r_pay_set_rub(pay, 4, 20);
            yk_r_pay_set_desc(pay, "it's 4:20");
            yk_r_pay_set_email(pay, "test@example.org");
            yk_r_pay_set_name(pay, "John Doe");
            yk_r_pay_add_item(pay, "grass", 4, 20);
            yk_payment n_pay = yk_pay(yk, &pay);

            char desc[yk_pay_print_len];
            yk_pay_print(n_pay, desc);
            printf("Created a payment: %s\n", desc);

            break;
        case ev_yk_init_fail:
            fprintf(stderr, "init fail\n");
            goto quit;
        case ev_yk_pay_started:
            yk_payment pay = yk_pay_from_ev(&evs[i]);
            char desc[yk_pay_print_len];
            char url[yk_pay_url_len];
            yk_pay_url(pay, url);
            yk_pay_print(pay, desc);
            printf("Payment '%s': %s\n", desc, url);
            break;
        case ev_yk_pay_wait_capture:
            yk_payment pay = yk_pay_from_ev(&evs[i]);
            char desc[yk_pay_print_len];
            yk_pay_print(pay, desc);
            yk_pay_capture(pay);
            printf("Capturing payment %s\n", desc);
            break;
        case ev_yk_pay_captured:
            yk_payment pay = yk_pay_from_ev(&evs[i]);
            char desc[yk_pay_print_len];
            yk_pay_print(pay, desc);
            printf("Payment captured: %s\n", desc);
            goto quit;
        case ev_yk_pay_fail:
            yk_payment pay = yk_pay_from_ev(&evs[i]);
            char p_desc[yk_pay_print_len];
            char desc[yk_pay_fail_desc_len];
            yk_pay_fail_desc(pay, desc);
            yk_pay_print(pay, p_desc);
            printf("Payment '%s' failed: %s\n", p_desc, desc);
            goto quit;
        case ev_yk_capture_fail:
            fprintf(stderr, "Capture failed\n");
            goto quit;
        case ev_yk_pay_expired:
            fprintf(stderr, "Expired\n");
            goto quit;
        }
    }
}

quit:
yk_stop_prep(yk);
while (1) {
    struct pollfd pollfds[42];
    nfds_t nfds = yk_pollfds(yk, pollfds, 42);
    poll(pollfds, nfds, 10000);
    yk_update(yk, pollfds, nfds);
    uint16_t n_evs = yk_events(yk, evs, 228);
    for (int i = 0; i < n_evs; i++) {
        switch (sob_ev_type(evs[i])) {
        case ev_yk_stopped:
            goto stopped;
        }
    }
}
stopped:
yk_stop(yk);
#+end_src
** "les": Lessons storage
*** Data
**** "lessons": Module state
**** "lesson": Lesson handle
***** "lesson_enabled": true if it can be displayed to users and purchased
***** "lesson_title": utf-8 string, max length - "les_title_len"
***** "lesson_desc": utf-8 string, max length - "les_desc_len"
***** "lesson_price": two uint - rub and kopek
***** "lesson_pos": for sorting the list displayed to user, duplicates possible
***** "lesson_print": ascii string to use in logs, max length - "lesson_print_len"
**** "lesson_new": Lesson data for "les_add"
***** "lesson_n_set_title": set "lesson_title"
***** "lesson_n_set_desc": set "lesson_desc"
***** "lesson_n_set_price": set "lesson_desc"
***** "lesson_n_set_pos": set "lesson_pos"
*** Events
**** "ev_les_init": after "les_init"
**** "ev_les_init_fail": after "les_init"
**** "ev_les_stopped": "les_stop" can be called after "les_stop_prep"
**** "ev_les_write_fail": change cannot be saved to disk, adding or modifying lessons is pointles
**** "ev_les_disabled": lesson is disabled immediately after "les_disable" (no "les_update" required) but the change may not be saved to disk yet
**** "ev_les_added": after "les_add"
**** "ev_les_new_title": after "les_set_title"
**** "ev_les_new_desc": after "les_set_desc"
**** "ev_les_new_price": after "les_set_price"
*** Methods
**** "les_init": start initialization
- Events: "ev_les_init", "ev_les_init_fail"
- Second call will do nothing
- Module will actually initialize after "ev_les_init"
- Methods if called immediately after will fail. Exceptions: "les_pollfds", "les_update", "les_events" - they will work normally
**** "les_stop_prep": begin module shutdown. "les_pollfds" must be serviced, possibly multiple times
- Events: "ev_les_stoppped"
**** "les_stop": signal the module that the program is closing
- Use only after event "ev_les_stopped"
- "les_pollfds" and "les_events" will be empty after this call
- All other methods will fail
- Call "les_init" to use the module again
**** "les_events": get list of module specific events
- Multiple calls will return same events before "les_update"
- Old events are removed after "les_update"
**** "les_pollfds": get list of "pollfs" to watch for
**** "les_update": notify the module about result of "poll"
**** "les_list": get list of enabled "lesson" that can be displayed to user
- Max number of lessons - "les_list_len"
- A returned "lesson" may become disabled after "les_disable"
**** "les_add": create a lesson using "lesson_new" and return "lesson"
- Events "ev_les_added", "ev_write_fail". Both may happen in that order
- Adds a second lesson if called twice
- New lesson will be listed in "les_list" immediately (before "les_update") even if it is not save to disk yet
**** "les_disable": disable "lesson"
- Events: "ev_les_disabled", "ev_les_write_fail". Both may happen in that order
- No effect if already disabled
- Effective immediately (before "les_update") even if the change is not saved to disk yet
**** "les_set_title": edit "lesson_title"
- Events: "ev_les_new_title", "ev_les_write_fail". Both may happen in that order
- Effective immediately
**** "les_set_desc": edit "lesson_desc"
- Events: "ev_les_new_desc", "ev_les_write_fail". Both may happen in that order
- Effective immediately
**** "les_set_price": edit "lesson_price"
- Events: "ev_les_new_price", "ev_les_write_fail". Both may happen in that order
- Effective immediately
*** Data storage
**** File name: "$PWD/lessons.txt"
**** Keys: ascii, values: utf-8
**** Keys are in format "<handle id>.<key>" where "<handle id>" corresponds to a "lesson" handle
**** Keys end with ":". Spaces and tabs around ":" are ignored
**** Description starts with "<" and end with ">". "<" and ">" are escaped as "\<" and "\>"
**** Description is multiline and formatted with Telegram markdownV2
**** First newline and spaces after "<" is ignored". First newline and spaces before ">" is ignored
**** Other values are enclosed in double quotes. Everything inside quotes is treated literally
** "acc": Accounts, list of unlocked Lessons for each user
*** Dependencies
**** "tg": Data "tg_chat"
**** "yk": Data "yk_payment"
**** "les": Data "lesson"
*** Data
**** "accounts": Module handle
**** "account"
***** "account_lessons": list of unlocked "lesson" handles including deactivated ones, max length - "account_lessons_len"
***** "account_payments": list of all successful and pending payments for the account as "yk_payment", max length - "account_payments_len"
*** Events
**** "ev_acc_init": after "acc_init"
**** "ev_acc_init_fail": after "acc_init"
**** "ev_acc_stopped": after "acc_stop_prep"
**** "ev_acc_new": account was created after "acc_new"
**** "ev_acc_new_fail": after "acc_new"
**** "ev_acc_les_unlocked": after "acc_unlock"
**** "ev_acc_unlock_fail": after "acc_unlock"
*** Methods
**** "acc_init": start initialization
- Events: "ev_acc_init", "ev_acc_init_fail"
- Second call will do nothing
- Module will actually initialize after "ev_acc_init"
- Methods if called immediately after will fail. Exceptions: "acc_pollfds", "acc_update", "acc_events" - they will work normally
**** "acc_stop_prep": begin module shutdown. "acc_pollfds" must be serviced, possibly multiple times
- Events: "ev_acc_stoppped"
**** "acc_stop": signal the module that the program is closing
- Use only after event "ev_acc_stopped"
- "acc_pollfds" and "acc_events" will be empty after this call
- All other methods will fail
- Call "acc_init" to use the module again
**** "acc_events": get list of module specific events
- Multiple calls will return same events before "acc_update"
- Old events are removed after "acc_update"
**** "acc_pollfds": get list of "pollfs" to watch for
**** "acc_update": notify the module about result of "poll"
**** "acc_acc_new": create an "account" for "tg_chat"
- Events: "ev_acc_new", "ev_acc_new_fail"
- Fails immediately if already exists
- Does not return a handle, us "acc_from_tg"
**** "acc_from_tg": get "account" handle for the user in "tg_chat"
- Fails immediately if nonexistent
**** "acc_unlock_les": adds a "lesson" to "account_lessons" and its "yk_payment" to "account_payments"
- Events: "acc_les_unlocked", "acc_unlock_fail"
*** Data storage
**** File name: "$PWD/acc.txt"
**** Keys and values: ascii
**** Keys are in format "<handle id>.<key>" where "<handle id>" corresponds to an "account" handle
**** Keys end with ":". Spaces and tabs around ":" are ignored
**** Values are enclosed in double quotes. Everything inside quotes is treated literally
**** Lists are in format 'key : "<first>", "<second>" , "<third>"'
** "str": Strings storage
*** Data
**** "str_p_%": a struct per each string for the matching "str_%" method, contains a field per a variable in the string
- Struct fields may be used directly instead of accessor methods
*** Events
**** "ev_str_init": after "str_init"
**** "ev_str_init_fail": after "str_init"
**** "ev_str_stopped": after "str_stop_prep"
*** Methods
**** "str_init": start initialization
- Events: "ev_str_init", "ev_str_init_fail"
- Second call will do nothing
- Module will actually initialize after "ev_str_init"
- Methods if called immediately after will fail. Exceptions: "str_pollfds", "str_update", "str_events" - they will work normally
**** "str_stop_prep": begin module shutdown. "str_pollfds" must be serviced, possibly multiple times
- Events: "ev_str_stoppped"
**** "str_stop": signal the module that the program is closing
- Use only after event "ev_str_stopped"
- "str_pollfds" and "str_events" will be empty after this call
- All other methods will fail
- Call "str_init" to use the module again
**** "str_events": get list of module specific events
- Multiple calls will return same events before "str_update"
- Old events are removed after "str_update"
**** "str_pollfds": get list of "pollfs" to watch for
**** "str_update": notify the module about result of "poll"
**** "str_%": method per each string, takes "str_p_%" if the string has variables
*** Data storage
**** File name: "$PWD/str.txt"
**** Keys: ascii, values: utf-8, comments: ascii
**** Strings are multiline
**** Strings are formatted with Telegram markdownV2
**** Strings contain substitution variables starting with "$" ("\$" for literal "$")
**** Variables are substituted only once. "$" in variable values is inserted literally
**** Program will not start if there are undefined variables. List of variables depend on a key
**** Strings start with "<" and end with ">". "<" and ">" are escaped as "\<" and "\>"
**** First newline after "<" is ignored". First newline before ">" is ignored
**** Keys end with ":". Spaces before ":" are ignored
**** Line is a comment if a "#" is at position 0 and it is not inside string. There are no comments inside strings
** "cred": Credentials storage
*** Data
*** Events
**** "ev_cred_init": after "cred_init"
**** "ev_cred_init_fail": after "cred_init"
**** "ev_cred_stopped": after "cred_stop_prep"
*** Methods
**** "cred_init": start initialization
- Events: "ev_cred_init", "ev_cred_init_fail"
- Second call will do nothing
- Module will actually initialize after "ev_cred_init"
- Methods if called immediately after will fail. Exceptions: "cred_pollfds", "cred_update", "cred_events" - they will work normally
**** "cred_stop_prep": begin module shutdown. "cred_pollfds" must be serviced, possibly multiple times
- Events: "ev_cred_stoppped"
**** "cred_stop": signal the module that the program is closing
- Use only after event "ev_cred_stopped"
- "cred_pollfds" and "cred_events" will be empty after this call
- All other methods will fail
- Call "cred_init" to use the module again
**** "cred_events": get list of module specific events
- Multiple calls will return same events before "cred_update"
- Old events are removed after "cred_update"
**** "cred_pollfds": get list of "pollfs" to watch for
**** "cred_update": notify the module about result of "poll"
**** "cred_tg_token": ascii string for "tg", max length - "cred_tg_token_len"
**** "cred_yk_shop_id": ascii string for "yk", max length - "cred_yk_shop_id_len" 
**** "cred_yk_token": ascii string for "yk", max length - "cred_yk_token_len" 
*** Data storage
**** Filen name: "$PWD/cre.dat". Name should not contain words like "credentials" to protect against automated attacks
**** Deobfuscated file content should be in ascii
**** Key and value are on the same line
**** Key-value separator is ":". Spaces and tabs before and after ":" are ignored.
**** Values are enclosed in double quotes. Everything inside quotes is treated literally
**** All content is obfuscated by bitwise negating to protect against automated attacks that rely on patterns
**** Line is a comment if "#" is at position 0
**** There should be a program for editing the file
** "cfg": Configuration
*** Data
**** "cfg": Module state
*** Methods
**** "cfg_%": a method per value, return type depends on value, max length should be specified for all strings and lists as "cfg_%_len"
** "log": Logger
*** Data
**** "log": Module state
*** Methods
**** "log_err", "log_warn", "log_info", "log_debug", "log_trace": parameters as in "printf(3)"
** "bot": Main module
*** Dependencies
**** Owns and wraps: "tg", "yk", "les", "acc"
**** Uses and receives: "cfg", "cred", "log"
*** Events
**** "ev_bot_init": after "bot_init"
**** "ev_bot_init_fail": after "bot_init"
**** "ev_bot_stopped": after "bot_stop_prep"
*** Methods
**** "bot_init": start initialization
- Events: "ev_bot_init", "ev_bot_init_fail"
- Second call will do nothing
- Module will actually initialize after "ev_bot_init"
- Methods if called immediately after will fail. Exceptions: "bot_pollfds", "bot_update", "bot_events" - they will work normally
**** "bot_stop_prep": begin module shutdown. "bot_pollfds" must be serviced, possibly multiple times
- Events: "ev_bot_stoppped"
**** "bot_stop": signal the module that the program is closing
- Use only after event "ev_bot_stopped"
- "bot_pollfds" and "bot_events" will be empty after this call
- All other methods will fail
- Call "bot_init" to use the module again
**** "bot_events": get list of module specific events
- Multiple calls will return same events before "bot_update"
- Old events are removed after "bot_update"
**** "bot_pollfds": get list of "pollfs" to watch for
**** "bot_update": notify the module about result of "poll"

* External services
** Telegram
*** HTTPS
*** Auth using a Token
*** Rate limit for messages is 1 per second for one chat and 30/s total
*** Updates are received via long-polling
*** Receive messages: GET "getUpdates"
**** Parameters
***** "offset": uint32, minimal value for "update_id" of returned updates. highest received "update_id" + 1.
Have to remember the highest "update_id"
***** "limit": uint32, max number of returned updates
***** "timeout": uint32 seconds, how long to keep the request pending if there are no updates
***** "allowed_updates": list of strings, only specified update types will be sent
"message", "edited_message", "callback_query"
**** Result
***** A JSON list of Update objects
***** "update_id": uint32, unique identifier. Update identifiers start from a positive number and increase sequentially
If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially.
***** Some Update types interesting to us (optional fields of the Update object):
****** "message": Message, a message was sent by a user
****** "edited_message": Message
****** "callback_query": CallbackQuery, an inline keyboard button was pressed
*** Send messages or add/remove the keyboard: POST sendMessage
**** Parameters
***** "chat_id": uint64
***** "text": utf-8 string, 1-4096 characters after entities parsing
***** "parse_mode": optional ascii string, enum: "MarkdownV2", "HTML", "Markdown"
***** "link_preview_options": optional LinkPreviewOptions
****** "is_disabled": optional bool
****** "url": optional utf-8 string, url preview instead of the first on in the message
****** "prefer_small_media": optional bool, is the media in the link preview is supposed to be shrunk
****** "show_above_text": optional bool
***** "protect_content": optional bool, protects the contents of the sent message from forwarding and saving
***** "reply_parameters": optional ReplyParameters
****** "message_id": uint32
***** "reply_markup": optional InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove
**** Result
***** Sent Message object
*** Edit message text: POST editMessageText
**** Parameters
***** "chat_id": uint64
***** "message_id": uint32
***** "text": utf-8 string, 1-4096 characters after entities parsing
***** "parse_mode": optional ascii string, enum: "MarkdownV2", "HTML", "Markdown"
***** "link_preview_options": optional LinkPreviewOptions
****** "is_disabled": optional bool
****** "url": optional utf-8 string, url preview instead of the first on in the message
****** "prefer_small_media": optional bool, is the media in the link preview is supposed to be shrunk
****** "show_above_text": optional bool
***** "reply_markup": optional InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove
*** Edit message markup: POST editMessageReplyMarkup
**** Parameters
***** "chat_id": uint64
***** "message_id": uint32
***** "reply_markup": optional InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove
*** Delete a message : POST deleteMessage
**** A message can only be deleted if it was sent less than 48 hours ago.
**** Parameters
***** "chat_id": uint64
***** "message_id": uint32
*** Forward message: POST forwardMessage
**** Parameters
***** "chat_id": uint64, target chat
***** "from_chat_id": uint64
***** "message_id": uint32
***** "disable_notification": optional bool, user will receive notification without sound
**** Result
Sent Message
*** Objects
**** All objects are transmited in JSON
**** Message (only interesting fields)
***** "message_id": uint32, unique id inside the "chat"
***** "chat": Chat
***** "from": User
***** "text": optional utf-8 string
***** "date": uint32, unix timestamp
***** "reply_to_message": optional Message, this object will not contain "reply_to_message"
***** "edit_date": optional uint32, unix timestamp
**** Chat (interesting fields)
***** "id": uint64
**** User (interesting fields)
***** "id": uint64
***** "first_name": utf-8 string
***** "last_name": utf-8 string
***** "username": ascii string
**** CallbackQuery
***** "id": string (encoding unknown)
***** "from": User
***** "message": Message, message sent by the bot with the button
In fact, it is MaybeInaccessibleMessage but we will make sure not to delete messages with buttons
**** InlineKeyboardMarkup
***** "inline_keyboard": list of lists of InlineKeyboardButton, each element of the first list represents a row
****** Exactly one optional field must be used
****** "text": utf-8 string
****** "url": optional utf-8 string, opened when the button is pressed
****** "callback_data": optional ascii string, 1-64 bytes
**** ReplyKeyboardMarkup
***** Buttons below the text input
***** "keyboard": list of lists of KeyboardButton, each element of the first list represents a row
****** "text": utf-8 string
This will be sent after clicking
***** "is_persistent": optional bool, always show the keyboard when the regular keyboard is hidden
***** "resize_keyboard": optional bool, use an optimal height instead of the height of the regular keyboard
***** "one_time_keyboard": optional bool, hide after the first use (can still be opened via a button)
**** ReplyKeyboardRemove
***** "remove_keyboard": bool, True
** Youkassa
*** Internet acquiring
*** HTTPS
*** Auth using a Shop-id and a Token
*** Post and Delete requests have an idempotence key
*** Updates are received using polling
*** Create a payment: POST payments
**** Parameters
***** "amount": object, additional commission is not included in this amount
****** "value": ascii string: number with a dot decimal separator
****** "currency": ascii string: "RUB", ISO-4217
***** "description: optional utf-8 string, up to 128 chars, and shown to the user during checkout
***** "receipt": object
****** "customer": object
******* "email": utf-8 string, can be replaced with "phone", used to send a receipt
******* "phone": ascii string, can be replaced with "email", ITU-T E.164, 
******* "full_name": optional utf-8 string, up to 256 chars
****** "items": list of object, up to 6 items for self-employed
******* "description": utf-8 stirng, up to 128 chars
******* "amount": object
******** "value": ascii string: number with a dot decimal separator
******** "currency": ascii string: "RUB", ISO-4217
******* "vat_code": uint8, 1-6, for self-employed should be "1"
******* "quantity": ascii string, nonzero uint
******* "measure": ascii string, enum, will use "piece"
******* "payment_subject": ascii string, enum, will use "commodity"
******* "payment_mode": ascii string, enum, will use "full_payment"
***** "confirmation": object, user confirmation scenario
****** "type": ascii stirng, "redirect"
****** "confirmation_url": ascii string, we should redirect user here to pay
****** "return_url": ascii string, user will be redirected here after successful or failed payment, up to 2048 chars 
****** "locale": optional ascii string, ui language, enum "ru_RU", "en_US"
***** "capture": bool, false for two-stage payment
***** "metadata": optional object, up to 16 keys, max key length is 32 chars, value: utf-8 string up to 512 chars
**** Result
Payment object
*** Capture a payment: POST payments/{payment_id}/capture
**** Can only be used for payments in state "waiting_for_capture"
**** Payment status will become "succeeded" on success
**** Result
Actual Payment object
*** Cancel a payment: POST payments/{payment_id}/cancel
**** Can only be used for payments in state "waiting_for_capture"
**** Result
Actual Payment object
*** Create a receipt: POST receipts
**** Parameters
***** "type": ascii string, enum "payment", "refund"
***** "payment_id": ascii string: 36 chars
***** "customer": object
****** "email": utf-8 string, can be replaced with "phone", used to send a receipt
****** "phone": ascii string, can be replaced with "email", ITU-T E.164, 
****** "full_name": optional utf-8 string, up to 256 chars
***** "items": list of object, up to 6 items for self-employed
****** "description": utf-8 stirng, up to 128 chars
****** "amount": object
******* "value": ascii string: number with a dot decimal separator
******* "currency": ascii string: "RUB", ISO-4217
****** "vat_code": uint8, 1-6, for self-employed should be "1"
****** "quantity": ascii string, nonzero uint
****** "measure": ascii string, enum, will use "piece"
****** "payment_subject": ascii string, enum, will use "commodity"
****** "payment_mode": ascii string, enum, will use "full_payment"
***** "send": bool, should always be "true"
***** "settlements": list of object
****** "type": ascii string, enum, will use "cashless"
****** "amount": object
******* "value": ascii string: number with a dot decimal separator
******* "currency": ascii string: "RUB", ISO-4217
**** Result
Receipt object
*** Payment lifecycle
**** "pending": payment is created and awaiting user actions. Next states: "succeeded", "waiting_for_capture", "canceled"
**** "waiting_for_capture": payment is made, authorized and waiting for us to request an actual transfer (to capture). Next states: "succeeded", "canceled"
**** "succeeded": funds will be transfered to us, final status
**** "canceled": final status
*** Objects
**** Payment
***** "id": ascii string: 36 chars
***** "status": ascii string: enum "pending", "waiting_for_capture", "succeeded", "canceled"
***** "amount": object, additional commission is not included in this amount
****** "value": ascii string: number with a dot decimal separator
****** "currency": ascii string: "RUB", ISO-4217
***** "description: optional utf-8 string, up to 128 chars, and shown to the user during checkout
***** "recipient": object
****** "account_id": ascii string
****** "gateway_id": ascii string, subaccount's ID. Used for separating payment flows within one account
***** "payment_method": optional object
****** "type": ascii string, payment method code
****** "id": ascii string
****** "saved": bool
****** "title": optional utf-8 string
***** "created_at": ascii string, UTC, ISO 8601
***** "captured_at": optional ascii string, UTC, ISO 8601
***** "expires_at": optional ascii string, UTC, ISO 8601, up to this time a payment can be cancelled free of charge.
if payment has status "waiting_for_capture" it will be automatically cancelled at this time
***** "confirmation": object, user confirmation scenario
****** "type": ascii stirng, "redirect"
****** "confirmation_url": ascii string, we should redirect user here to pay
****** "return_url": optional ascii string, user will be redirected here after successful or failed payment, up to 2048 chars 
***** "test": bool, is a test operation
***** "paid": bool
***** "refundable": bool
***** "receipt_registration": optional bool, enum "pending", "succeeded", "canceled"
present if automatic sending of receipts to the tax service is enabled
***** "metadata": optional object, up to 16 keys, max key length is 32 chars, value: utf-8 string up to 512 chars
***** "cancellation_details": optional object, comment to the "cancelled" status
****** "party": ascii string, enum "yoo_money", "payment_network", "merchant"
****** "reason": ascii string, enum
https://yookassa.ru/developers/payment-acceptance/after-the-payment/declined-payments#cancellation-details-reason
***** "authorization_details": optional object
****** "three_d_secure": object, data about auth with 3‑D Secure
******* "applied": bool, true - Youkass displayed a 3-D form, false - paid without 3-D
****** "rrn": optional ascii string, Retrieval Reference Number, present if paid with a debit card
****** "auth_code": optional ascii stirng, present for debit card payments
**** Receipt
***** "id": ascii string, 39 chars
***** "type": ascii string, enum "payment", "refund"
***** "payment_id": ascii string: 36 chars
***** "status": ascii string, enum "pending", "succeeded", "canceled"
***** "items": object, see "items" in Parameters of "Create a payment"
***** "fiscal_document_number": optional ascii string
***** "fiscal_storage_number": optional ascii string
***** "fiscal_attribute": optional ascii string
***** "registered_at": optional ascii string, ISO 8601
***** "fiscal_provider_id": optional ascii string, receipt id in the online sales register
*** Errors
**** Error object
***** Returned for HTTP codes 400, 401, 403, 404, 429 and 500
***** "type": ascii string, always "error"
***** "id": ascii string, use for tech support
***** "code": ascii string, enum "invalid_request", "invalid_credentials", "forbidden", "not_found", "too_many_requests", "internal_server_error"
***** "description": ascii string
***** "parameter": optional ascii string, header or parameter that caused the error
**** HTTP 400: invalid_request, error in request syntax or logic, new idempotence key
**** HTTP 401: invalid_credentials, old or new idempotence key
**** HTTP 403: forbidden, not enough permissions for an operation, new idempotence key
**** HTTP 404: not_found, resource not found, new idempotence key
**** HTTP 405: incorrect HTTP method, no Error object, description in the "Reason-Phrase" header, new idempotence key
**** HTTP 415: invalid "Content-type" for POST, no Error object, description in the "Reason-Phrase" header, new idempotence key
**** HTTP 429: too_many_requests, old idempotence key
**** HTTP 500: internal_server_error, request may or may not be successful, repeat request with same idempotence key

